### 一、什么是MVVM

MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

### 二、`mvvm`和`mvc`区别？它和其它框架（`jquery`）的区别是什么？哪些场景适用？

mvc和mvvm其实区别并不大，都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。

区别：vue数据驱动，通过数据来显示视图层而不是节点操作。

场景：数据操作比较多、频繁的场景，更加便捷。

### 三、`vue`的优点是什么？

低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。

可重用性。可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。

独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。

可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。

### 四、 组件之间的传值？

- 父组件通过标签上`:data=data`方式定义传值
- 子组件通过`props`方法接受数据
- 子组件通过`$emit`方法传递参数

### 五、`vuex`是什么？怎么使用？哪种功能场景使用它？

`vue`框架中**状态管理**。在`main.js`引入`store`注入。新建一个目录`store` 。

场景有：单页应用中，组件之间的状态，音乐播放、登录状态、加入购物车等。

### 六、`vuex`有哪几种属性？

有五种，分别是 `State`、 `Getter`、`Mutation` 、`Action`、 `Module`。

###### （1）vuex的State特性

Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data。

state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。

通过mapState把全局 state 和 getters 映射到当前组件的 computed 计算属性中。

###### （2）vuex的Getter特性

getters 可以对State进行计算操作，它就是Store的计算属性。

虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用。

如果一个状态只在一个组件内使用，可以不用getters。

###### （3）vuex的Mutation特性

Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。

**（mutation中是一个同步方法，Action 是异步）**

###### （4）不用`Vuex`会带来什么问题？

- 可维护性会下降，想修改数据要维护三个地方；
- 可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；
- 增加耦合，大量的上传派发，会让耦合性大大增加，`Vue`用`Component`本意就是为了减少耦合，现在这么用，和组件化的初衷相背。

### 七、 `v-show`和`v-if`指令的共同点和不同点

- `v-show`指令是通过修改元素的`display`的`CSS`属性让其显示或者隐藏；
- `v-if`指令是直接**销毁**和**重建**`DOM`达到让元素显示和隐藏的效果；
- 使用`v-show`会更加节省性能上的开销；当只需要一次显示或隐藏时，使用`v-if`更加合理。

### 八、 如何让`CSS`只在当前组件中起作用

将当前组件的`<style>`修改为`<style scoped>`。

### 九、说出至少4种vue当中的指令和它的用法

- `v-if`：判断是否隐藏；
- `v-for`：数据循环；
- `v-bind:class`：绑定一个属性；
- `v-model`：实现双向绑定；

### 九、为什么v-if和v-for不应该一起用

1. 当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级

2. 哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。（这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中

   所以，不推荐v-if和v-for同时使用）

### 十、生命周期函数面试题

##### 1. 什么是vue生命周期？

Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-渲染、更新-渲染、卸载等一系列的过程，我们称这是 Vue 的生命周期。

##### 2. vue生命周期的作用是什么

Vue 所有的功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。 生命周期中有多个事件钩子，在控制整个vue实例的过程时更容易形成好的逻辑。

##### 3. 第一次页面加载会触发哪几个钩子？

beforeCreate ， created ， beforeMount ，mounted 这几个钩子

##### 4. 简述每个周期具体适合哪些场景？

- beforeCreate：创建前，此阶段为实例初始化之后，this指向创建的实例，此时的数据观察事件机制都未形成，不能获得DOM节点。

  data，computed，watch，methods 上的方法和数据均不能访问。

  可以在这加个loading事件。

- created：创建后，此阶段为实例已经创建，完成数据（data、props、computed）的初始化导入依赖项。

  可访问 data computed watch methods 上的方法和数据。

  初始化完成时的事件写在这里，异步请求也适宜在这里调用（请求不宜过多，避免白屏时间太长）。

  可以在这里结束loading事件，还做一些初始化，实现函数自执行。

  未挂载DOM，若在此阶段进行DOM操作一定要放在Vue.nextTick()的回调函数中。

- beforeMount：挂载前，虽然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行。

  beforeMount这个阶段是过渡性的，一般一个项目只能用到一两次。

- mounted：挂载，完成创建vm.$el，和双向绑定

  完成挂载DOM和渲染，可在mounted钩子函数中对挂载的DOM进行操作。

  可在这发起后端请求，拿回数据，配合路由钩子做一些事情。

- beforeUpdate：数据更新前，数据驱动DOM。

  在数据更新后虽然没有立即更新数据，但是DOM中的数据会改变，这是vue双向数据绑定的作用。

  可在更新前访问现有的DOM，如手动移出添加的事件监听器。

- updated：数据更新后，完成虚拟DOM的重新渲染和打补丁。

  组件DOM已完成更新，可执行依赖的DOM操作。

  注意：不要在此函数中操作数据（修改属性），会陷入死循环。

- activated：在使用vue-router时有时需要使用`<keep-alive></keep-alive>`来缓存组件状态，这个时候created钩子就不会被重复调用了。

  如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发。

- deactivated：`<keep-alive></keep-alive>`组件被移除时使用。

- beforeDestroy：销毁前，

  可做一些删除提示，如：您确定删除xx吗？

- destroyed：销毁后，当前组件已被删除，销毁监听事件，组件、事件、子实例也被销毁。

  这时组件已经没有了，无法操作里面的任何东西了。

##### 5. 父子组件的生命周期

- 执行顺序：
  - 父组件开始执行到beforeMount 然后开始子组件执行，最后是父组件mounted。
  - 如果有兄弟组件，父组件开始执行到beforeMount，然后兄弟组件依次执行到beforeMount，然后按照顺序执行mounted，最后执行父组件的mounted。
- 当子组件挂载完成后，父组件才会挂载。
- 当子组件完成挂在后，父组件会主动执行一次beforeUpdated/updated钩子函数（仅首次）
- 父子组件在data变化中是分别监控的，但是更新props中的数据是关联的。
- 销毁父组件时，先将子组件销毁后才会销毁父组件。
- 兄弟组件的初始化（mounted之前）是分开进行，挂载是从上到下依次进行
- 当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的